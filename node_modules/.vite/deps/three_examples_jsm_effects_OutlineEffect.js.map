{
  "version": 3,
  "sources": ["../../three/examples/jsm/effects/OutlineEffect.js"],
  "sourcesContent": ["import {\r\n\tBackSide,\r\n\tColor,\r\n\tShaderMaterial,\r\n\tUniformsLib,\r\n\tUniformsUtils\r\n} from 'three';\r\n\r\n/**\r\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\r\n *\r\n * API\r\n *\r\n * 1. Traditional\r\n *\r\n * const effect = new OutlineEffect( renderer );\r\n *\r\n * function render() {\r\n *\r\n * \teffect.render( scene, camera );\r\n *\r\n * }\r\n *\r\n * 2. VR compatible\r\n *\r\n * const effect = new OutlineEffect( renderer );\r\n * let renderingOutline = false;\r\n *\r\n * scene.onAfterRender = function () {\r\n *\r\n * \tif ( renderingOutline ) return;\r\n *\r\n * \trenderingOutline = true;\r\n *\r\n * \teffect.renderOutline( scene, camera );\r\n *\r\n * \trenderingOutline = false;\r\n *\r\n * };\r\n *\r\n * function render() {\r\n *\r\n * \trenderer.render( scene, camera );\r\n *\r\n * }\r\n *\r\n * // How to set default outline parameters\r\n * new OutlineEffect( renderer, {\r\n * \tdefaultThickness: 0.01,\r\n * \tdefaultColor: [ 0, 0, 0 ],\r\n * \tdefaultAlpha: 0.8,\r\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\r\n * } );\r\n *\r\n * // How to set outline parameters for each material\r\n * material.userData.outlineParameters = {\r\n * \tthickness: 0.01,\r\n * \tcolor: [ 0, 0, 0 ],\r\n * \talpha: 0.8,\r\n * \tvisible: true,\r\n * \tkeepAlive: true\r\n * };\r\n */\r\n\r\nclass OutlineEffect {\r\n\r\n\tconstructor( renderer, parameters = {} ) {\r\n\r\n\t\tthis.enabled = true;\r\n\r\n\t\tconst defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\r\n\t\tconst defaultColor = new Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );\r\n\t\tconst defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\r\n\t\tconst defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\r\n\r\n\t\t// object.material.uuid -> outlineMaterial or\r\n\t\t// object.material[ n ].uuid -> outlineMaterial\r\n\t\t// save at the outline material creation and release\r\n\t\t// if it's unused removeThresholdCount frames\r\n\t\t// unless keepAlive is true.\r\n\t\tconst cache = {};\r\n\r\n\t\tconst removeThresholdCount = 60;\r\n\r\n\t\t// outlineMaterial.uuid -> object.material or\r\n\t\t// outlineMaterial.uuid -> object.material[ n ]\r\n\t\t// save before render and release after render.\r\n\t\tconst originalMaterials = {};\r\n\r\n\t\t// object.uuid -> originalOnBeforeRender\r\n\t\t// save before render and release after render.\r\n\t\tconst originalOnBeforeRenders = {};\r\n\r\n\t\t//this.cache = cache;  // for debug\r\n\r\n\t\tconst uniformsOutline = {\r\n\t\t\toutlineThickness: { value: defaultThickness },\r\n\t\t\toutlineColor: { value: defaultColor },\r\n\t\t\toutlineAlpha: { value: defaultAlpha }\r\n\t\t};\r\n\r\n\t\tconst vertexShader = [\r\n\t\t\t'#include <common>',\r\n\t\t\t'#include <uv_pars_vertex>',\r\n\t\t\t'#include <displacementmap_pars_vertex>',\r\n\t\t\t'#include <fog_pars_vertex>',\r\n\t\t\t'#include <morphtarget_pars_vertex>',\r\n\t\t\t'#include <skinning_pars_vertex>',\r\n\t\t\t'#include <logdepthbuf_pars_vertex>',\r\n\t\t\t'#include <clipping_planes_pars_vertex>',\r\n\r\n\t\t\t'uniform float outlineThickness;',\r\n\r\n\t\t\t'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {',\r\n\t\t\t'\tfloat thickness = outlineThickness;',\r\n\t\t\t'\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\r\n\t\t\t'\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\r\n\t\t\t// NOTE: subtract pos2 from pos because BackSide objectNormal is negative\r\n\t\t\t'\tvec4 norm = normalize( pos - pos2 );',\r\n\t\t\t'\treturn pos + norm * thickness * pos.w * ratio;',\r\n\t\t\t'}',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\t#include <uv_vertex>',\r\n\r\n\t\t\t'\t#include <beginnormal_vertex>',\r\n\t\t\t'\t#include <morphnormal_vertex>',\r\n\t\t\t'\t#include <skinbase_vertex>',\r\n\t\t\t'\t#include <skinnormal_vertex>',\r\n\r\n\t\t\t'\t#include <begin_vertex>',\r\n\t\t\t'\t#include <morphtarget_vertex>',\r\n\t\t\t'\t#include <skinning_vertex>',\r\n\t\t\t'\t#include <displacementmap_vertex>',\r\n\t\t\t'\t#include <project_vertex>',\r\n\r\n\t\t\t'\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\r\n\r\n\t\t\t'\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );',\r\n\r\n\t\t\t'\t#include <logdepthbuf_vertex>',\r\n\t\t\t'\t#include <clipping_planes_vertex>',\r\n\t\t\t'\t#include <fog_vertex>',\r\n\r\n\t\t\t'}',\r\n\r\n\t\t].join( '\\n' );\r\n\r\n\t\tconst fragmentShader = [\r\n\r\n\t\t\t'#include <common>',\r\n\t\t\t'#include <fog_pars_fragment>',\r\n\t\t\t'#include <logdepthbuf_pars_fragment>',\r\n\t\t\t'#include <clipping_planes_pars_fragment>',\r\n\r\n\t\t\t'uniform vec3 outlineColor;',\r\n\t\t\t'uniform float outlineAlpha;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\t#include <clipping_planes_fragment>',\r\n\t\t\t'\t#include <logdepthbuf_fragment>',\r\n\r\n\t\t\t'\tgl_FragColor = vec4( outlineColor, outlineAlpha );',\r\n\r\n\t\t\t'\t#include <tonemapping_fragment>',\r\n\t\t\t'\t#include <colorspace_fragment>',\r\n\t\t\t'\t#include <fog_fragment>',\r\n\t\t\t'\t#include <premultiplied_alpha_fragment>',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' );\r\n\r\n\t\tfunction createMaterial() {\r\n\r\n\t\t\treturn new ShaderMaterial( {\r\n\t\t\t\ttype: 'OutlineEffect',\r\n\t\t\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\t\t\tUniformsLib[ 'fog' ],\r\n\t\t\t\t\tUniformsLib[ 'displacementmap' ],\r\n\t\t\t\t\tuniformsOutline\r\n\t\t\t\t] ),\r\n\t\t\t\tvertexShader: vertexShader,\r\n\t\t\t\tfragmentShader: fragmentShader,\r\n\t\t\t\tside: BackSide\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getOutlineMaterialFromCache( originalMaterial ) {\r\n\r\n\t\t\tlet data = cache[ originalMaterial.uuid ];\r\n\r\n\t\t\tif ( data === undefined ) {\r\n\r\n\t\t\t\tdata = {\r\n\t\t\t\t\tmaterial: createMaterial(),\r\n\t\t\t\t\tused: true,\r\n\t\t\t\t\tkeepAlive: defaultKeepAlive,\r\n\t\t\t\t\tcount: 0\r\n\t\t\t\t};\r\n\r\n\t\t\t\tcache[ originalMaterial.uuid ] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdata.used = true;\r\n\r\n\t\t\treturn data.material;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getOutlineMaterial( originalMaterial ) {\r\n\r\n\t\t\tconst outlineMaterial = getOutlineMaterialFromCache( originalMaterial );\r\n\r\n\t\t\toriginalMaterials[ outlineMaterial.uuid ] = originalMaterial;\r\n\r\n\t\t\tupdateOutlineMaterial( outlineMaterial, originalMaterial );\r\n\r\n\t\t\treturn outlineMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isCompatible( object ) {\r\n\r\n\t\t\tconst geometry = object.geometry;\r\n\t\t\tconst hasNormals = ( geometry !== undefined ) && ( geometry.attributes.normal !== undefined );\r\n\r\n\t\t\treturn ( object.isMesh === true && object.material !== undefined && hasNormals === true );\r\n\r\n\t\t}\r\n\r\n\t\tfunction setOutlineMaterial( object ) {\r\n\r\n\t\t\tif ( isCompatible( object ) === false ) return;\r\n\r\n\t\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tobject.material[ i ] = getOutlineMaterial( object.material[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.material = getOutlineMaterial( object.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toriginalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;\r\n\t\t\tobject.onBeforeRender = onBeforeRender;\r\n\r\n\t\t}\r\n\r\n\t\tfunction restoreOriginalMaterial( object ) {\r\n\r\n\t\t\tif ( isCompatible( object ) === false ) return;\r\n\r\n\t\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tobject.material[ i ] = originalMaterials[ object.material[ i ].uuid ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.material = originalMaterials[ object.material.uuid ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.onBeforeRender = originalOnBeforeRenders[ object.uuid ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction onBeforeRender( renderer, scene, camera, geometry, material ) {\r\n\r\n\t\t\tconst originalMaterial = originalMaterials[ material.uuid ];\r\n\r\n\t\t\t// just in case\r\n\t\t\tif ( originalMaterial === undefined ) return;\r\n\r\n\t\t\tupdateUniforms( material, originalMaterial );\r\n\r\n\t\t}\r\n\r\n\t\tfunction updateUniforms( material, originalMaterial ) {\r\n\r\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\r\n\r\n\t\t\tmaterial.uniforms.outlineAlpha.value = originalMaterial.opacity;\r\n\r\n\t\t\tif ( outlineParameters !== undefined ) {\r\n\r\n\t\t\t\tif ( outlineParameters.thickness !== undefined ) material.uniforms.outlineThickness.value = outlineParameters.thickness;\r\n\t\t\t\tif ( outlineParameters.color !== undefined ) material.uniforms.outlineColor.value.fromArray( outlineParameters.color );\r\n\t\t\t\tif ( outlineParameters.alpha !== undefined ) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( originalMaterial.displacementMap ) {\r\n\r\n\t\t\t\tmaterial.uniforms.displacementMap.value = originalMaterial.displacementMap;\r\n\t\t\t\tmaterial.uniforms.displacementScale.value = originalMaterial.displacementScale;\r\n\t\t\t\tmaterial.uniforms.displacementBias.value = originalMaterial.displacementBias;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction updateOutlineMaterial( material, originalMaterial ) {\r\n\r\n\t\t\tif ( material.name === 'invisible' ) return;\r\n\r\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\r\n\r\n\t\t\tmaterial.fog = originalMaterial.fog;\r\n\t\t\tmaterial.toneMapped = originalMaterial.toneMapped;\r\n\t\t\tmaterial.premultipliedAlpha = originalMaterial.premultipliedAlpha;\r\n\t\t\tmaterial.displacementMap = originalMaterial.displacementMap;\r\n\r\n\t\t\tif ( outlineParameters !== undefined ) {\r\n\r\n\t\t\t\tif ( originalMaterial.visible === false ) {\r\n\r\n\t\t\t\t\tmaterial.visible = false;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterial.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;\r\n\r\n\t\t\t\tif ( outlineParameters.keepAlive !== undefined ) cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial.transparent = originalMaterial.transparent;\r\n\t\t\t\tmaterial.visible = originalMaterial.visible;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) material.visible = false;\r\n\r\n\t\t\tif ( originalMaterial.clippingPlanes ) {\r\n\r\n\t\t\t\tmaterial.clipping = true;\r\n\r\n\t\t\t\tmaterial.clippingPlanes = originalMaterial.clippingPlanes;\r\n\t\t\t\tmaterial.clipIntersection = originalMaterial.clipIntersection;\r\n\t\t\t\tmaterial.clipShadows = originalMaterial.clipShadows;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.version = originalMaterial.version; // update outline material if necessary\r\n\r\n\t\t}\r\n\r\n\t\tfunction cleanupCache() {\r\n\r\n\t\t\tlet keys;\r\n\r\n\t\t\t// clear originialMaterials\r\n\t\t\tkeys = Object.keys( originalMaterials );\r\n\r\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\t\toriginalMaterials[ keys[ i ] ] = undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// clear originalOnBeforeRenders\r\n\t\t\tkeys = Object.keys( originalOnBeforeRenders );\r\n\r\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\t\toriginalOnBeforeRenders[ keys[ i ] ] = undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// remove unused outlineMaterial from cache\r\n\t\t\tkeys = Object.keys( cache );\r\n\r\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst key = keys[ i ];\r\n\r\n\t\t\t\tif ( cache[ key ].used === false ) {\r\n\r\n\t\t\t\t\tcache[ key ].count ++;\r\n\r\n\t\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {\r\n\r\n\t\t\t\t\t\tdelete cache[ key ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcache[ key ].used = false;\r\n\t\t\t\t\tcache[ key ].count = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.render = function ( scene, camera ) {\r\n\r\n\t\t\tif ( this.enabled === false ) {\r\n\r\n\t\t\t\trenderer.render( scene, camera );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst currentAutoClear = renderer.autoClear;\r\n\t\t\trenderer.autoClear = this.autoClear;\r\n\r\n\t\t\trenderer.render( scene, camera );\r\n\r\n\t\t\trenderer.autoClear = currentAutoClear;\r\n\r\n\t\t\tthis.renderOutline( scene, camera );\r\n\r\n\t\t};\r\n\r\n\t\tthis.renderOutline = function ( scene, camera ) {\r\n\r\n\t\t\tconst currentAutoClear = renderer.autoClear;\r\n\t\t\tconst currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\r\n\t\t\tconst currentSceneBackground = scene.background;\r\n\t\t\tconst currentShadowMapEnabled = renderer.shadowMap.enabled;\r\n\r\n\t\t\tscene.matrixWorldAutoUpdate = false;\r\n\t\t\tscene.background = null;\r\n\t\t\trenderer.autoClear = false;\r\n\t\t\trenderer.shadowMap.enabled = false;\r\n\r\n\t\t\tscene.traverse( setOutlineMaterial );\r\n\r\n\t\t\trenderer.render( scene, camera );\r\n\r\n\t\t\tscene.traverse( restoreOriginalMaterial );\r\n\r\n\t\t\tcleanupCache();\r\n\r\n\t\t\tscene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\r\n\t\t\tscene.background = currentSceneBackground;\r\n\t\t\trenderer.autoClear = currentAutoClear;\r\n\t\t\trenderer.shadowMap.enabled = currentShadowMapEnabled;\r\n\r\n\t\t};\r\n\r\n\t\t/*\r\n\t\t * See #9918\r\n\t\t *\r\n\t\t * The following property copies and wrapper methods enable\r\n\t\t * OutlineEffect to be called from other *Effect, like\r\n\t\t *\r\n\t\t * effect = new StereoEffect( new OutlineEffect( renderer ) );\r\n\t\t *\r\n\t\t * function render () {\r\n\t\t *\r\n\t \t * \teffect.render( scene, camera );\r\n\t\t *\r\n\t\t * }\r\n\t\t */\r\n\t\tthis.autoClear = renderer.autoClear;\r\n\t\tthis.domElement = renderer.domElement;\r\n\t\tthis.shadowMap = renderer.shadowMap;\r\n\r\n\t\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\t\trenderer.clear( color, depth, stencil );\r\n\r\n\t\t};\r\n\r\n\t\tthis.getPixelRatio = function () {\r\n\r\n\t\t\treturn renderer.getPixelRatio();\r\n\r\n\t\t};\r\n\r\n\t\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\t\trenderer.setPixelRatio( value );\r\n\r\n\t\t};\r\n\r\n\t\tthis.getSize = function ( target ) {\r\n\r\n\t\t\treturn renderer.getSize( target );\r\n\r\n\t\t};\r\n\r\n\t\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\t\trenderer.setSize( width, height, updateStyle );\r\n\r\n\t\t};\r\n\r\n\t\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\t\trenderer.setViewport( x, y, width, height );\r\n\r\n\t\t};\r\n\r\n\t\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\t\trenderer.setScissor( x, y, width, height );\r\n\r\n\t\t};\r\n\r\n\t\tthis.setScissorTest = function ( boolean ) {\r\n\r\n\t\t\trenderer.setScissorTest( boolean );\r\n\r\n\t\t};\r\n\r\n\t\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\t\trenderer.setRenderTarget( renderTarget );\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { OutlineEffect };\r\n"],
  "mappings": "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",
  "names": ["renderer"]
}
